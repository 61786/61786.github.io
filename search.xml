<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring boot 之 Schedlued</title>
    <url>/uncategorized/Spring%20boot%20%E4%B9%8B%20Schedlued/</url>
    <content><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>SpringBoot自带的 Schedule，可以将它看成一个轻量级的Quartz，而且使用起来比Quartz简单许多</p>
<p>第一步：可以再自定义的类上添加@EnableScheduling 开启定时任务，也可以再启动器上加上该注解开启</p>
<p>第二步： 在对应的方法上加入@Scheduled  其中有三个属性分别是</p>
<p>1.fixedRate：会为所有任务的开始执行时间编排一个表，假如fixedRate=5000，且第一次开始时间是10:00:00 </p>
<p><code>当执行任务耗时小于fixedRate设置的时间时，将会按照表中的开始时间执行任务，即每隔5秒会执行一个任务</code>： </p>
<p> 当执行任务耗时大于fixedRate设置的时间时，以下一张图就很清楚的表示了 </p>
<p>解析一下：</p>
<p>fixedRate设置的也是为fixedRate=5000</p>
<p>第一个任务开始执行时间是0:00,耗时8秒</p>
<p>第二个任务本应该开始执行时间是0：05，但是第一个任务执行完时间已经是0：08，所以第二个任务在第一个任务执行完毕之后会立即执行，耗时是3s</p>
<p>第三个任务本应该开始执行时间是0：10，但是前两个任务执行完毕时间已经是0：11，所以第三个任务在第二个任务执行完毕之后会立即执行，耗时是6s</p>
<p>第四个任务，也同第二、第三个任务一样，在预计开始执行的时间（这里第四个任务预计开始执行时间是0:15），因为上一个任务还没有执行完毕，所以要等待上一个人执行完毕之后才会执行。</p>
<p>第五个任务预计开始执行时间是0:20，而前四个任务在0:19已经执行完毕，需要等待1秒，到达我们预计的开始执行时间（0:20）才会执行第五个任务。</p>
<p>2.fixedDelay</p>
<p>这个就比之前的fixedRate简单得多。如设置fixedRate=5000.下一个任务只需要盯着上一个任务的屁股（执行完毕的时间）就行了。上一个任务执行完毕5秒之后，下一个任务就会开始执行</p>
<p>3.initialDelay</p>
<p>用于配合fixedRate和fixedDelay使用的，作用是在容器启动后经过多长时间才开始执行第一次任务。</p>
<p>4.cron</p>
<p>在指定的时间执行任务 根据表达式定义的不同 间隔时间不同如：0 0 1 * * ? 表示每天凌晨一点执行一次任务</p>
<p>想了解更多请自行修改。</p>
<p>————————————————<br>版权声明：本文为CSDN博主「小码农liangliping」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_33643072/article/details/81334268" target="_blank" rel="noopener">https://blog.csdn.net/qq_33643072/article/details/81334268</a> </p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7安装docker</title>
    <url>/uncategorized/centos7%E5%AE%89%E8%A3%85docker/</url>
    <content><![CDATA[<p>刚开始了解docker总是听说Docker 是一个<a href="https://baike.baidu.com/item/%E5%BC%80%E6%BA%90/246339" target="_blank" rel="noopener">开源</a>的应用容器引擎 让开发者可以打包他们的应用以及依赖包到一    个可移植的镜像中，然后发布到任何流行的 <a href="https://baike.baidu.com/item/Linux" target="_blank" rel="noopener">Linux</a>或Windows 机器上，也可以实现<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%8C%96/547949" target="_blank" rel="noopener">虚拟化</a>容器是完全使用<a href="https://baike.baidu.com/item/%E6%B2%99%E7%AE%B1/393318" target="_blank" rel="noopener">沙箱</a>机制，相互之间不会有任何接口。 处于对Docker的好奇准备操作一波，由于之前用的虚拟机是centos6版本而看到docker官网上说最低版本需要centos7内核版本3.0.8以上，果断下载centos7安装再次不多说。</p>
<p>开始讲安装docker过程：</p>
<ol>
<li>升级yum源</li>
<li>安装docker所需依赖包  yum update  2. yum install -y yum-utils device-mapper-persistent-data lvm2 </li>
<li>修改docker镜像源 yum-config-manager –add-repo <a href="https://download.docker.com/linux/centos/docker-ce.repo" target="_blank" rel="noopener">https://download.docker.com/linux/centos/docker-ce.repo</a> 发现还是一样的网速慢 使用docker命令提示连接异常</li>
<li>查看docker版本 yum list docker-ce –showduplicates | sort -r </li>
<li>根据需求选择对应docker版本yum install docker-ce-版本号 </li>
<li>启动docker:  systemctl start docker        加入开机启动  systemctl enable docker </li>
</ol>
<p>到此docker已安装完成 测试简单 hello-world命令  先pull镜像 docker pull hello-world  然后报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> docker: Error response from daemon: Get https:&#x2F;&#x2F;registry-1.docker.io&#x2F;v2&#x2F;: net&#x2F;http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers).</span><br><span class="line"></span><br><span class="line">See &#39;docker run --help&#39;.</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">百度需要修改docker镜像源 ： docker默认的源为国外官方源，下载速度较慢，可以改为国内，加速 </span><br><span class="line"></span><br><span class="line">方案一： 修改或新增 &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line"></span><br><span class="line">\# vi &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;http:&#x2F;&#x2F;hub-mirror.c.163.com&quot;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方案二：修改或新增 &#x2F;etc&#x2F;sysconfig&#x2F;docker，在OPTIONS变量后追加参数  --registry-mirror&#x3D;&lt;https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&gt;</span><br><span class="line"></span><br><span class="line">最终使用方案一解决： vi daemon.json </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;,&quot;http:&#x2F;&#x2F;hub-mirror.c.163.com&quot;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service docker restart 成功！</span><br></pre></td></tr></table></figure>

<p>最后赋上docker常见命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> -----------------     docker ps 查看当前正在运行的容器   -----------------    docker ps -a 查看所有容器的状态</span><br><span class="line">-----------------    docker start&#x2F;stop id&#x2F;name 启动&#x2F;停止某个容器    -----------------    docker attach id 进入某个容器(使用exit退出后容器也跟着停止运行)</span><br><span class="line">-----------------    docker exec -ti id 启动一个伪终端以交互式的方式进入某个容器（使用exit退出后容器不停止运行）</span><br><span class="line">-----------------    docker images 查看本地镜像    -----------------    docker rm id&#x2F;name 删除某个容器    -----------------     docker rmi id&#x2F;name 删除某个镜像</span><br><span class="line">-----------------    docker run --name test -ti ubuntu &#x2F;bin&#x2F;bash  复制ubuntu容器并且重命名为test且运行，然后以伪终端交互式方式进入容器，运行bash</span><br><span class="line">-----------------     docker build -t soar&#x2F;centos:7.1 .  通过当前目录下的Dockerfile创建一个名为soar&#x2F;centos:7.1的镜像</span><br><span class="line">-----------------    docker run -d -p 2222:22 --name test soar&#x2F;centos:7.1  以镜像soar&#x2F;centos:7.1创建名为test的容器，并以后台模式运行，并做端口映射到宿主机2222端口，P参数重启容器宿主机端口会发生改变</span><br></pre></td></tr></table></figure>









]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo搭建博客</title>
    <url>/uncategorized/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>之前上班由于比较忙，没时间将项目用过的东西记录下来等过段时间再用时发现大部分忘记了，看同事大部分都使用hexo博客来记录，话不多说直接搞起：</p>
<h4 id="技术选型：Git-Github-Markdown-hexo"><a href="#技术选型：Git-Github-Markdown-hexo" class="headerlink" title="技术选型：Git+Github+Markdown+hexo"></a>技术选型：Git+Github+Markdown+hexo</h4><p>   1.搭建准备工作： git下载安装及GitHub账号绑定 </p>
<p>   2.安装node.js 需要修改npm路径path</p>
<ol>
<li><p>安装hexo  验证是否成功  hexo server 如果hexo命令无法使用 将model下.bin路径加入path变量中  </p>
</li>
<li><p>创建github repositroy远程仓库 这里花了较多时间</p>
</li>
<li><p>部署本地文件到github </p>
</li>
<li><p>购买域名及配置SSH密钥等 设置SSH密钥后需要验证是否可用，配置DNS等</p>
</li>
</ol>
<p>至此 博客已经搭建完毕 本地访问4000端口可预览！搭建好之后有没有原主题很low，我们可以去 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">博客主题网站</a>  来选择自己喜欢的主题样式down下来修改 _config.yml文件主题配置名即可  。     修改主题命令为（git bash下）hexo generate –deploy   hexo g -d  即可！</p>
<hr>
<p>接下来要忙的就是发布自己的博客 使用任意markdown格式的笔记 小编使用的Typora 感觉蛮好用，再Typora编辑好博客后使用 hexo new (文章命名自定义)     hexo g      hexo d 即可查看新增的博客！！！</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot访问html</title>
    <url>/uncategorized/springboot%E8%AE%BF%E9%97%AEhtml/</url>
    <content><![CDATA[<h3 id="一、什么是Beetl"><a href="#一、什么是Beetl" class="headerlink" title="一、什么是Beetl"></a>一、什么是Beetl</h3><h4 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Beetl是Bee Template Language的缩写，它绝不是简单的另外一种模板引擎，而是新一代的模板引擎，它功能强大，性能良好，超过当前流行的模板引擎。而且还易学易用。</span><br></pre></td></tr></table></figure>

<h4 id="1-2-优缺点"><a href="#1-2-优缺点" class="headerlink" title="1.2 优缺点"></a>1.2 优缺点</h4><p>1.2.1 优点： 易整合、性能强 </p>
<p>1.2.2 缺点： 文档蛋疼、用例少、与html标签结合略显混乱</p>
<h3 id="二、Beetl语法"><a href="#二、Beetl语法" class="headerlink" title="二、Beetl语法"></a>二、Beetl语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参考官网语法 (http:&#x2F;&#x2F;ibeetl.com&#x2F;guide&#x2F;#beetl)</span><br><span class="line">在线体验 (http:&#x2F;&#x2F;ibeetl.com&#x2F;beetlonline&#x2F;)</span><br></pre></td></tr></table></figure>

<h3 id="三、第一个例子：与SpringBoot集成"><a href="#三、第一个例子：与SpringBoot集成" class="headerlink" title="三、第一个例子：与SpringBoot集成"></a>三、第一个例子：与SpringBoot集成</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;1.5.3.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;relativePath&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.ibeetl&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;beetl-framework-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;1.1.60.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-关于启动器的说明"><a href="#3-3-关于启动器的说明" class="headerlink" title="3.3 关于启动器的说明"></a>3.3 关于启动器的说明</h3><blockquote>
<p>starter 自动处理以btl结尾的视图，模板根目录是Spring Boot默认的templates目录。</p>
</blockquote>
<h3 id="3-4-使用默认配置"><a href="#3-4-使用默认配置" class="headerlink" title="3.4 使用默认配置"></a>3.4 使用默认配置</h3><ul>
<li>创建HelloController(<strong>return “/hello.btl”;</strong>)</li>
<li>在templates下创建 hello.btl</li>
</ul>
<h3 id="3-5-启动运行效果"><a href="#3-5-启动运行效果" class="headerlink" title="3.5 启动运行效果"></a>3.5 启动运行效果</h3><blockquote>
<p><strong>Hello,This is a BTL file, The time is 2018-09-05 10:09:12</strong></p>
</blockquote>
<p>由于springboot 不支持html直接解析显示页面 ，官网上介绍说需要使用模板引擎入Freemark,Thymeleaf …</p>
<p>但是感觉限制太大需要学习相关的语法然后发现beetl模板，速度比以上两款速度快废话不多说贴代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Beetl配置</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Configuration</span><br><span class="line">public class BeetlExtConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;beetlConfig&quot;)</span><br><span class="line">    public BeetlGroupUtilConfiguration getBeetlGroupUtilConfiguration() &#123;</span><br><span class="line">        BeetlGroupUtilConfiguration beetlGroupUtilConfiguration &#x3D; new BeetlGroupUtilConfiguration();</span><br><span class="line">        beetlGroupUtilConfiguration.setResourceLoader(new ClasspathResourceLoader(&quot;pages&#x2F;&quot;));</span><br><span class="line">        beetlGroupUtilConfiguration.init();</span><br><span class="line">        GroupTemplate groupTemplate &#x3D; beetlGroupUtilConfiguration.getGroupTemplate();</span><br><span class="line">        &#x2F;&#x2F; 读取配置文件信息</span><br><span class="line">        return beetlGroupUtilConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;beetlViewResolver&quot;)</span><br><span class="line">    public BeetlSpringViewResolver getBeetlSpringViewResolver(@Qualifier(&quot;beetlConfig&quot;) BeetlGroupUtilConfiguration</span><br><span class="line">                                                                      beetlGroupUtilConfiguration) &#123;</span><br><span class="line">        BeetlSpringViewResolver beetlSpringViewResolver &#x3D; new BeetlSpringViewResolver();</span><br><span class="line">        beetlSpringViewResolver.setSuffix(&quot;.html&quot;);</span><br><span class="line">        beetlSpringViewResolver.setOrder(0);</span><br><span class="line">        beetlSpringViewResolver.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);</span><br><span class="line">        beetlSpringViewResolver.setConfig(beetlGroupUtilConfiguration);</span><br><span class="line">        return beetlSpringViewResolver;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>yml配置 并不需要配置 prefix,  Suffix</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvc:</span><br><span class="line">    static-path-pattern: &#x2F;static&#x2F;**</span><br></pre></td></tr></table></figure>

<p>启动tomcat运行成功显示html页面</p>
<p>网上看到第二种方式也可以测试ok  在resources下方添加beetl.properties文件添加如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RESOURCE.root&#x3D;&#x2F;pages&#x2F;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ResourcePatternResolver resolver &#x3D; new PathMatchingResourcePatternResolver();</span><br><span class="line">beetlGroupUtilConfiguration.setConfigFileResource(resolver.getResource(&quot;classpath:beetl.properties&quot;));</span><br></pre></td></tr></table></figure>







]]></content>
      <tags>
        <tag>beetl</tag>
      </tags>
  </entry>
  <entry>
    <title>spring依赖springboot项目异常</title>
    <url>/uncategorized/spring%E4%BE%9D%E8%B5%96springboot%E9%A1%B9%E7%9B%AE%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>场景昨天晚上有需求需要在本项目中依赖整合其它系统的dubbo服务  </p>
<p>本项目为spring+dubbo服务 </p>
<p>外部系统springboot+dubbo服务 </p>
<p>在项目中service项目引入外部jar包依赖后项目一直启动报错，首先是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SLF4J: Class path contains multiple SLF4J bindings.</span><br><span class="line">SLF4J: Found binding in [jar:file:...&#x2F;repository&#x2F;ch&#x2F;qos&#x2F;logback&#x2F;logback-classic&#x2F;1.1.7&#x2F;logback-classic-1.1.7.jar!&#x2F;org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class]</span><br><span class="line">SLF4J: Found binding in [jar:file:...&#x2F;repository&#x2F;org&#x2F;slf4j&#x2F;slf4j-log4j12&#x2F;1.7.21&#x2F;slf4j-log4j12-1.7.21.jar!&#x2F;org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class]</span><br></pre></td></tr></table></figure>

<p>由log可以看到因为由多个<code>SLF4J bindings</code>绑定  ,即存在多个SLF4J实现类 ，去掉不需要的jar解决</p>
<p>排除之后没想到又报错了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.beans.factory.BeanDefinitionStoreException: IOException parsing XML document from ServletContext resource [&#x2F;WEB-INF&#x2F;springmvc-servlet.xml]; nested exception is java.io.FileNotFoundException: Could not open ServletContext resource [&#x2F;NONE]</span><br><span class="line">	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:341)</span><br><span class="line">	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:302)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:174)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:209)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:180)</span><br><span class="line">	at org.springframework.web.context.support.XmlWebApplicationContext.loadBeanDefinitions(XmlWebApplicationContext.java:125)</span><br><span class="line">	at org.springframework.web.context.support.XmlWebApplicationContext.loadBeanDefinitions(XmlWebApplicationContext.java:94)</span><br><span class="line">	at org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:131)</span><br></pre></td></tr></table></figure>

<p>一般情况下是找不到xml文件了 由于本项目service没有web-inf更没有web.xml 所以报错加上之后ok,但是由于测试，生产环境更改可能引起不必要的问题，所以第二种解决方法 排除外部jar包中的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring-boot-start</span><br></pre></td></tr></table></figure>

<p>终于完美解决 ，spring-boot-start为什么会引起这个问题待研究</p>
]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>spring dubbo项目依赖springboot dubbo项目启动失败</title>
    <url>/uncategorized/spring%20dubbo%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96springboot%20dubbo%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<h5 id="spring-dubbo项目依赖springboot-dubbo项目启动失败"><a href="#spring-dubbo项目依赖springboot-dubbo项目启动失败" class="headerlink" title="spring dubbo项目依赖springboot dubbo项目启动失败"></a>spring dubbo项目依赖springboot dubbo项目启动失败</h5><p>场景昨天晚上有需求需要在本项目中依赖整合其它系统的dubbo服务  </p>
<p>本项目为spring+dubbo服务 </p>
<p>外部系统springboot+dubbo服务 </p>
<p>在项目中service项目引入外部jar包依赖后项目一直启动报错，首先是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SLF4J: Class path contains multiple SLF4J bindings.</span><br><span class="line">SLF4J: Found binding in [jar:file:...&#x2F;repository&#x2F;ch&#x2F;qos&#x2F;logback&#x2F;logback-classic&#x2F;1.1.7&#x2F;logback-classic-1.1.7.jar!&#x2F;org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class]</span><br><span class="line">SLF4J: Found binding in [jar:file:...&#x2F;repository&#x2F;org&#x2F;slf4j&#x2F;slf4j-log4j12&#x2F;1.7.21&#x2F;slf4j-log4j12-1.7.21.jar!&#x2F;org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class]</span><br></pre></td></tr></table></figure>

<p>由log可以看到因为由多个<code>SLF4J bindings</code>绑定  ,即存在多个SLF4J实现类 ，去掉不需要的jar解决</p>
<p>排除之后没想到又报错了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.beans.factory.BeanDefinitionStoreException: IOException parsing XML document from ServletContext resource [&#x2F;WEB-INF&#x2F;springmvc-servlet.xml]; nested exception is java.io.FileNotFoundException: Could not open ServletContext resource [&#x2F;NONE]</span><br><span class="line">	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:341)</span><br><span class="line">	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:302)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:174)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:209)</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:180)</span><br><span class="line">	at org.springframework.web.context.support.XmlWebApplicationContext.loadBeanDefinitions(XmlWebApplicationContext.java:125)</span><br><span class="line">	at org.springframework.web.context.support.XmlWebApplicationContext.loadBeanDefinitions(XmlWebApplicationContext.java:94)</span><br><span class="line">	at org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:131)</span><br></pre></td></tr></table></figure>

<p>一般情况下是找不到xml文件了 由于本项目service没有web-inf更没有web.xml 所以报错加上之后ok,但是由于测试，生产环境更改可能引起不必要的问题，所以第二种解决方法 排除外部jar包中的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring-boot-start</span><br></pre></td></tr></table></figure>

<p>终于完美解决 ，spring-boot-start为什么会引起这个问题待研究</p>
]]></content>
  </entry>
</search>
